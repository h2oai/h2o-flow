// Generated by CoffeeScript 1.11.1
(function() {
  var createCheckboxControl, createControl, createControlFromParameter, createDropdownControl, createGridableValues, createListControl, createTextboxControl;

  createControl = function(kind, parameter) {
    var _hasError, _hasInfo, _hasMessage, _hasWarning, _isGrided, _isNotGrided, _isVisible, _message;
    _hasError = signal(false);
    _hasWarning = signal(false);
    _hasInfo = signal(false);
    _message = signal('');
    _hasMessage = lift(_message, function(message) {
      if (message) {
        return true;
      } else {
        return false;
      }
    });
    _isVisible = signal(true);
    _isGrided = signal(false);
    _isNotGrided = lift(_isGrided, function(value) {
      return !value;
    });
    return {
      kind: kind,
      name: parameter.name,
      label: parameter.label,
      description: parameter.help,
      isRequired: parameter.required,
      hasError: _hasError,
      hasWarning: _hasWarning,
      hasInfo: _hasInfo,
      message: _message,
      hasMessage: _hasMessage,
      isVisible: _isVisible,
      isGridable: parameter.gridable,
      isGrided: _isGrided,
      isNotGrided: _isNotGrided
    };
  };

  createTextboxControl = function(parameter, type) {
    var _text, _textGrided, _value, _valueGrided, control, isArrayValued, isInt, isReal, ref, ref1, textToValues;
    isArrayValued = isInt = isReal = false;
    switch (type) {
      case 'byte[]':
      case 'short[]':
      case 'int[]':
      case 'long[]':
        isArrayValued = true;
        isInt = true;
        break;
      case 'float[]':
      case 'double[]':
        isArrayValued = true;
        isReal = true;
        break;
      case 'byte':
      case 'short':
      case 'int':
      case 'long':
        isInt = true;
        break;
      case 'float':
      case 'double':
        isReal = true;
    }
    _text = signal(isArrayValued ? join((ref = parameter.actual_value) != null ? ref : [], ', ') : (ref1 = parameter.actual_value) != null ? ref1 : '');
    _textGrided = signal(_text() + ';');
    textToValues = function(text) {
      var j, len, parsed, ref2, vals, value;
      if (isArrayValued) {
        vals = [];
        ref2 = split(text, /\s*,\s*/g);
        for (j = 0, len = ref2.length; j < len; j++) {
          value = ref2[j];
          if (isInt) {
            if (!isNaN(parsed = parseInt(value, 10))) {
              vals.push(parsed);
            }
          } else if (isReal) {
            if (!isNaN(parsed = parseFloat(value))) {
              vals.push(parsed);
            }
          } else {
            vals.push(value);
          }
        }
        return vals;
      } else {
        return text;
      }
    };
    _value = lift(_text, textToValues);
    _valueGrided = lift(_textGrided, function(text) {
      var j, len, part, ref2, token, values;
      values = [];
      ref2 = ("" + text).split(/\s*;\s*/g);
      for (j = 0, len = ref2.length; j < len; j++) {
        part = ref2[j];
        if (token = part.trim()) {
          push(values, textToValues(token));
        }
      }
      return values;
    });
    control = createControl('textbox', parameter);
    control.text = _text;
    control.textGrided = _textGrided;
    control.value = _value;
    control.valueGrided = _valueGrided;
    control.isArrayValued = isArrayValued;
    return control;
  };

  createGridableValues = function(values, defaultValue) {
    return map(values, function(value) {
      return {
        label: value,
        value: signal(true)
      };
    });
  };

  createDropdownControl = function(parameter) {
    var _value, control;
    _value = signal(parameter.actual_value);
    control = createControl('dropdown', parameter);
    control.values = signals(parameter.values);
    control.value = _value;
    control.gridedValues = lift(control.values, function(values) {
      return createGridableValues(values);
    });
    return control;
  };

  createListControl = function(parameter) {
    var MaxItemsPerPage, _canGoToNextPage, _canGoToPreviousPage, _currentPage, _entries, _filteredItems, _hasFilteredItems, _ignoreNATerm, _isUpdatingSelectionCount, _lastUsedIgnoreNaTerm, _lastUsedSearchTerm, _maxPages, _searchCaption, _searchTerm, _selectionCount, _values, _visibleItems, blockSelectionUpdates, changeSelection, control, createEntry, deselectFiltered, filterItems, goToNextPage, goToPreviousPage, incrementSelectionCount, selectFiltered;
    MaxItemsPerPage = 100;
    _searchTerm = signal('');
    _ignoreNATerm = signal('');
    _values = signal([]);
    _selectionCount = signal(0);
    _isUpdatingSelectionCount = false;
    blockSelectionUpdates = function(f) {
      _isUpdatingSelectionCount = true;
      f();
      return _isUpdatingSelectionCount = false;
    };
    incrementSelectionCount = function(amount) {
      return _selectionCount(_selectionCount() + amount);
    };
    createEntry = function(value) {
      var isSelected;
      isSelected = signal(false);
      react(isSelected, function(isSelected) {
        if (!_isUpdatingSelectionCount) {
          if (isSelected) {
            incrementSelectionCount(1);
          } else {
            incrementSelectionCount(-1);
          }
        }
      });
      return {
        isSelected: isSelected,
        value: value.value,
        type: value.type,
        missingLabel: value.missingLabel,
        missingPercent: value.missingPercent
      };
    };
    _entries = lift(_values, function(values) {
      return map(values, createEntry);
    });
    _filteredItems = signal([]);
    _visibleItems = signal([]);
    _hasFilteredItems = lift(_filteredItems, function(entries) {
      return entries.length > 0;
    });
    _currentPage = signal(0);
    _maxPages = lift(_filteredItems, function(entries) {
      return Math.ceil(entries.length / MaxItemsPerPage);
    });
    _canGoToPreviousPage = lift(_currentPage, function(index) {
      return index > 0;
    });
    _canGoToNextPage = lift(_maxPages, _currentPage, function(maxPages, index) {
      return index < maxPages - 1;
    });
    _searchCaption = lift(_entries, _filteredItems, _selectionCount, _currentPage, _maxPages, function(entries, filteredItems, selectionCount, currentPage, maxPages) {
      var caption;
      caption = maxPages === 0 ? '' : "Showing page " + (currentPage + 1) + " of " + maxPages + ".";
      if (filteredItems.length !== entries.length) {
        caption += " Filtered " + filteredItems.length + " of " + entries.length + ".";
      }
      if (selectionCount !== 0) {
        caption += " " + selectionCount + " ignored.";
      }
      return caption;
    });
    react(_entries, function() {
      return filterItems(true);
    });
    _lastUsedSearchTerm = null;
    _lastUsedIgnoreNaTerm = null;
    filterItems = function(force) {
      var entry, filteredItems, hide, i, ignoreNATerm, j, len, missingPercent, ref, searchTerm, start;
      if (force == null) {
        force = false;
      }
      searchTerm = _searchTerm().trim();
      ignoreNATerm = _ignoreNATerm().trim();
      if (force || searchTerm !== _lastUsedSearchTerm || ignoreNATerm !== _lastUsedIgnoreNaTerm) {
        filteredItems = [];
        ref = _entries();
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          entry = ref[i];
          missingPercent = parseFloat(ignoreNATerm);
          hide = false;
          if ((searchTerm !== '') && -1 === entry.value.toLowerCase().indexOf(searchTerm.toLowerCase())) {
            hide = true;
          } else if ((!isNaN(missingPercent)) && (missingPercent !== 0) && entry.missingPercent <= missingPercent) {
            hide = true;
          }
          if (!hide) {
            filteredItems.push(entry);
          }
        }
        _lastUsedSearchTerm = searchTerm;
        _lastUsedIgnoreNaTerm = ignoreNATerm;
        _currentPage(0);
        _filteredItems(filteredItems);
      }
      start = _currentPage() * MaxItemsPerPage;
      _visibleItems(_filteredItems().slice(start, start + MaxItemsPerPage));
    };
    changeSelection = function(source, value) {
      var entry, j, len;
      for (j = 0, len = source.length; j < len; j++) {
        entry = source[j];
        entry.isSelected(value);
      }
    };
    selectFiltered = function() {
      var entries;
      entries = _filteredItems();
      blockSelectionUpdates(function() {
        return changeSelection(entries, true);
      });
      return _selectionCount(entries.length);
    };
    deselectFiltered = function() {
      blockSelectionUpdates(function() {
        return changeSelection(_filteredItems(), false);
      });
      return _selectionCount(0);
    };
    goToPreviousPage = function() {
      if (_canGoToPreviousPage()) {
        _currentPage(_currentPage() - 1);
        filterItems();
      }
    };
    goToNextPage = function() {
      if (_canGoToNextPage()) {
        _currentPage(_currentPage() + 1);
        filterItems();
      }
    };
    react(_searchTerm, throttle(filterItems, 500));
    react(_ignoreNATerm, throttle(filterItems, 500));
    control = createControl('list', parameter);
    control.values = _values;
    control.entries = _visibleItems;
    control.hasFilteredItems = _hasFilteredItems;
    control.searchCaption = _searchCaption;
    control.searchTerm = _searchTerm;
    control.ignoreNATerm = _ignoreNATerm;
    control.value = _entries;
    control.selectFiltered = selectFiltered;
    control.deselectFiltered = deselectFiltered;
    control.goToPreviousPage = goToPreviousPage;
    control.goToNextPage = goToNextPage;
    control.canGoToPreviousPage = _canGoToPreviousPage;
    control.canGoToNextPage = _canGoToNextPage;
    return control;
  };

  createCheckboxControl = function(parameter) {
    var _value, control;
    _value = signal(parameter.actual_value);
    control = createControl('checkbox', parameter);
    control.clientId = uniqueId();
    control.value = _value;
    return control;
  };

  createControlFromParameter = function(parameter) {
    switch (parameter.type) {
      case 'enum':
      case 'Key<Frame>':
      case 'VecSpecifier':
        return createDropdownControl(parameter);
      case 'string[]':
        return createListControl(parameter);
      case 'boolean':
        return createCheckboxControl(parameter);
      case 'Key<Model>':
      case 'string':
      case 'byte':
      case 'short':
      case 'int':
      case 'long':
      case 'float':
      case 'double':
      case 'byte[]':
      case 'short[]':
      case 'int[]':
      case 'long[]':
      case 'float[]':
      case 'double[]':
        return createTextboxControl(parameter, parameter.type);
      default:
        console.error('Invalid field', JSON.stringify(parameter, null, 2));
        return null;
    }
  };

  H2O.ModelBuilderForm = function(_, _algorithm, _parameters) {
    var _controlGroups, _exception, _form, _gridId, _gridMaxModels, _gridMaxRuntime, _gridStoppingMetric, _gridStoppingMetrics, _gridStoppingRounds, _gridStoppingTolerance, _gridStrategies, _gridStrategy, _hasValidationFailures, _isGridRandomDiscrete, _isGrided, _parametersByLevel, _revalidate, _validationFailureMessage, collectParameters, control, createModel, criticalControls, expertControls, findControl, findFormField, j, k, l, len, len1, len2, parameterTemplateOf, performValidations, revalidate, secondaryControls;
    _exception = signal(null);
    _validationFailureMessage = signal('');
    _hasValidationFailures = lift(_validationFailureMessage, isTruthy);
    _gridStrategies = ['Cartesian', 'RandomDiscrete'];
    _isGrided = signal(false);
    _gridId = signal("grid-" + (Flow.Util.uuid()));
    _gridStrategy = signal('Cartesian');
    _isGridRandomDiscrete = lift(_gridStrategy, function(strategy) {
      return strategy !== _gridStrategies[0];
    });
    _gridMaxModels = signal(1000);
    _gridMaxRuntime = signal(28800);
    _gridStoppingRounds = signal(0);
    _gridStoppingMetrics = ['AUTO', 'deviance', 'logloss', 'MSE', 'AUC', 'lift_top_group', 'r2', 'misclassification'];
    _gridStoppingMetric = signal(_gridStoppingMetrics[0]);
    _gridStoppingTolerance = signal(0.001);
    _parametersByLevel = groupBy(_parameters, function(parameter) {
      return parameter.level;
    });
    _controlGroups = map(['critical', 'secondary', 'expert'], function(type) {
      var controls;
      controls = filter(map(_parametersByLevel[type], createControlFromParameter), function(a) {
        if (a) {
          return true;
        } else {
          return false;
        }
      });
      forEach(controls, function(control) {
        return react(control.isGrided, function() {
          var isGrided, j, len;
          isGrided = false;
          for (j = 0, len = controls.length; j < len; j++) {
            control = controls[j];
            if (control.isGrided()) {
              _isGrided(isGrided = true);
              break;
            }
          }
          if (!isGrided) {
            return _isGrided(false);
          }
        });
      });
      return controls;
    });
    criticalControls = _controlGroups[0], secondaryControls = _controlGroups[1], expertControls = _controlGroups[2];
    _form = [];
    if (criticalControls.length) {
      _form.push({
        kind: 'group',
        title: 'Parameters'
      });
      for (j = 0, len = criticalControls.length; j < len; j++) {
        control = criticalControls[j];
        _form.push(control);
      }
    }
    if (secondaryControls.length) {
      _form.push({
        kind: 'group',
        title: 'Advanced'
      });
      for (k = 0, len1 = secondaryControls.length; k < len1; k++) {
        control = secondaryControls[k];
        _form.push(control);
      }
    }
    if (expertControls.length) {
      _form.push({
        kind: 'group',
        title: 'Expert'
      });
      for (l = 0, len2 = expertControls.length; l < len2; l++) {
        control = expertControls[l];
        _form.push(control);
      }
    }
    findControl = function(name) {
      var controls, len3, len4, m, n;
      for (m = 0, len3 = _controlGroups.length; m < len3; m++) {
        controls = _controlGroups[m];
        for (n = 0, len4 = controls.length; n < len4; n++) {
          control = controls[n];
          if (control.name === name) {
            return control;
          }
        }
      }
    };
    parameterTemplateOf = function(control) {
      return "flow-" + control.kind + "-model-parameter";
    };
    findFormField = function(name) {
      return find(_form, function(field) {
        return field.name === name;
      });
    };
    (function() {
      var foldColumnParameter, ignoredColumnsParameter, offsetColumnsParameter, ref, responseColumnParameter, trainingFrameParameter, validationFrameParameter, weightsColumnParameter;
      ref = map(['training_frame', 'validation_frame', 'response_column', 'ignored_columns', 'offset_column', 'weights_column', 'fold_column'], findFormField), trainingFrameParameter = ref[0], validationFrameParameter = ref[1], responseColumnParameter = ref[2], ignoredColumnsParameter = ref[3], offsetColumnsParameter = ref[4], weightsColumnParameter = ref[5], foldColumnParameter = ref[6];
      if (trainingFrameParameter) {
        if (responseColumnParameter || ignoredColumnsParameter) {
          return act(trainingFrameParameter.value, function(frameKey) {
            if (frameKey) {
              _.requestFrameSummaryWithoutData(frameKey, function(error, frame) {
                var columnLabels, columnValues;
                if (!error) {
                  columnValues = map(frame.columns, function(column) {
                    return column.label;
                  });
                  columnLabels = map(frame.columns, function(column) {
                    var missingPercent;
                    missingPercent = 100 * column.missing_count / frame.rows;
                    return {
                      type: column.type === 'enum' ? "enum(" + column.domain_cardinality + ")" : column.type,
                      value: column.label,
                      missingPercent: missingPercent,
                      missingLabel: missingPercent === 0 ? '' : (round(missingPercent)) + "% NA"
                    };
                  });
                  if (responseColumnParameter) {
                    responseColumnParameter.values(columnValues);
                  }
                  if (ignoredColumnsParameter) {
                    ignoredColumnsParameter.values(columnLabels);
                  }
                  if (weightsColumnParameter) {
                    weightsColumnParameter.values(columnValues);
                  }
                  if (foldColumnParameter) {
                    foldColumnParameter.values(columnValues);
                  }
                  if (offsetColumnsParameter) {
                    offsetColumnsParameter.values(columnValues);
                  }
                  if (responseColumnParameter && ignoredColumnsParameter) {
                    return lift(responseColumnParameter.value, function(responseVariableName) {});
                  }
                }
              });
            }
          });
        }
      }
    })();
    collectParameters = function(includeUnchangedParameters) {
      var controls, entry, gridStoppingRounds, hyperParameters, isGrided, item, len3, len4, len5, m, maxModels, maxRuntime, n, o, parameters, ref, searchCriteria, selectedValues, stoppingTolerance, value;
      if (includeUnchangedParameters == null) {
        includeUnchangedParameters = false;
      }
      isGrided = false;
      parameters = {};
      hyperParameters = {};
      for (m = 0, len3 = _controlGroups.length; m < len3; m++) {
        controls = _controlGroups[m];
        for (n = 0, len4 = controls.length; n < len4; n++) {
          control = controls[n];
          if (control.isGrided()) {
            isGrided = true;
            switch (control.kind) {
              case 'textbox':
                hyperParameters[control.name] = control.valueGrided();
                break;
              case 'dropdown':
                hyperParameters[control.name] = selectedValues = [];
                ref = control.gridedValues();
                for (o = 0, len5 = ref.length; o < len5; o++) {
                  item = ref[o];
                  if (item.value()) {
                    selectedValues.push(item.label);
                  }
                }
                break;
              default:
                hyperParameters[control.name] = [true, false];
            }
          } else {
            value = control.value();
            if (control.isVisible() && (includeUnchangedParameters || control.isRequired || (control.defaultValue !== value))) {
              switch (control.kind) {
                case 'dropdown':
                  if (value) {
                    parameters[control.name] = value;
                  }
                  break;
                case 'list':
                  if (value.length) {
                    selectedValues = (function() {
                      var len6, p, results;
                      results = [];
                      for (p = 0, len6 = value.length; p < len6; p++) {
                        entry = value[p];
                        if (entry.isSelected()) {
                          results.push(entry.value);
                        }
                      }
                      return results;
                    })();
                    parameters[control.name] = selectedValues;
                  }
                  break;
                default:
                  parameters[control.name] = value;
              }
            }
          }
        }
      }
      if (isGrided) {
        parameters.grid_id = _gridId();
        parameters.hyper_parameters = hyperParameters;
        searchCriteria = {
          strategy: _gridStrategy()
        };
        switch (searchCriteria.strategy) {
          case 'RandomDiscrete':
            if (!isNaN(maxModels = parseInt(_gridMaxModels(), 10))) {
              searchCriteria.max_models = maxModels;
            }
            if (!isNaN(maxRuntime = parseInt(_gridMaxRuntime(), 10))) {
              searchCriteria.max_runtime_secs = maxRuntime;
            }
            if (!isNaN(gridStoppingRounds = parseInt(_gridStoppingRounds(), 10))) {
              searchCriteria.stopping_rounds = gridStoppingRounds;
            }
            if (!isNaN(stoppingTolerance = parseFloat(_gridStoppingTolerance()))) {
              searchCriteria.stopping_tolerance = stoppingTolerance;
            }
            searchCriteria.stopping_metric = _gridStoppingMetric();
        }
        parameters.search_criteria = searchCriteria;
      }
      return parameters;
    };
    performValidations = function(checkForErrors, go) {
      var parameters;
      _exception(null);
      parameters = collectParameters(true);
      if (parameters.hyper_parameters) {
        return go();
      }
      _validationFailureMessage('');
      return _.requestModelInputValidation(_algorithm, parameters, function(error, modelBuilder) {
        var controls, hasErrors, len3, len4, len5, m, n, o, validation, validations, validationsByControlName;
        if (error) {
          return _exception(Flow.Failure(_, new Flow.Error('Error fetching initial model builder state', error)));
        } else {
          hasErrors = false;
          if (modelBuilder.messages.length) {
            validationsByControlName = groupBy(modelBuilder.messages, function(validation) {
              return validation.field_name;
            });
            for (m = 0, len3 = _controlGroups.length; m < len3; m++) {
              controls = _controlGroups[m];
              for (n = 0, len4 = controls.length; n < len4; n++) {
                control = controls[n];
                if (validations = validationsByControlName[control.name]) {
                  for (o = 0, len5 = validations.length; o < len5; o++) {
                    validation = validations[o];
                    if (validation.message_type === 'TRACE') {
                      control.isVisible(false);
                    } else {
                      control.isVisible(true);
                      if (checkForErrors) {
                        switch (validation.message_type) {
                          case 'INFO':
                            control.hasInfo(true);
                            control.message(validation.message);
                            break;
                          case 'WARN':
                            control.hasWarning(true);
                            control.message(validation.message);
                            break;
                          case 'ERRR':
                            control.hasError(true);
                            control.message(validation.message);
                            hasErrors = true;
                        }
                      }
                    }
                  }
                } else {
                  control.isVisible(true);
                  control.hasInfo(false);
                  control.hasWarning(false);
                  control.hasError(false);
                  control.message('');
                }
              }
            }
          }
          if (hasErrors) {
            return _validationFailureMessage('Your model parameters have one or more errors. Please fix them and try again.');
          } else {
            _validationFailureMessage('');
            return go();
          }
        }
      });
    };
    createModel = function() {
      _exception(null);
      return performValidations(true, function() {
        var parameters;
        parameters = collectParameters(false);
        return _.insertAndExecuteCell('cs', "buildModel '" + _algorithm + "', " + (stringify(parameters)));
      });
    };
    _revalidate = function(value) {
      if (value !== void 0) {
        return performValidations(false, function() {});
      }
    };
    revalidate = throttle(_revalidate, 100, {
      leading: false
    });
    performValidations(false, function() {
      var controls, len3, len4, m, n;
      for (m = 0, len3 = _controlGroups.length; m < len3; m++) {
        controls = _controlGroups[m];
        for (n = 0, len4 = controls.length; n < len4; n++) {
          control = controls[n];
          react(control.value, revalidate);
        }
      }
    });
    return {
      form: _form,
      isGrided: _isGrided,
      gridId: _gridId,
      gridStrategy: _gridStrategy,
      gridStrategies: _gridStrategies,
      isGridRandomDiscrete: _isGridRandomDiscrete,
      gridMaxModels: _gridMaxModels,
      gridMaxRuntime: _gridMaxRuntime,
      gridStoppingRounds: _gridStoppingRounds,
      gridStoppingMetrics: _gridStoppingMetrics,
      gridStoppingMetric: _gridStoppingMetric,
      gridStoppingTolerance: _gridStoppingTolerance,
      exception: _exception,
      parameterTemplateOf: parameterTemplateOf,
      createModel: createModel,
      hasValidationFailures: _hasValidationFailures,
      validationFailureMessage: _validationFailureMessage
    };
  };

  H2O.ModelInput = function(_, _go, _algo, _opts) {
    var _algorithm, _algorithms, _canCreateModel, _exception, _modelForm, createModel, populateFramesAndColumns;
    _exception = signal(null);
    _algorithms = signal([]);
    _algorithm = signal(null);
    _canCreateModel = lift(_algorithm, function(algorithm) {
      if (algorithm) {
        return true;
      } else {
        return false;
      }
    });
    _modelForm = signal(null);
    populateFramesAndColumns = function(frameKey, algorithm, parameters, go) {
      var classificationParameter, destinationKeyParameter;
      destinationKeyParameter = find(parameters, function(parameter) {
        return parameter.name === 'model_id';
      });
      if (destinationKeyParameter && !destinationKeyParameter.actual_value) {
        destinationKeyParameter.actual_value = algorithm + "-" + (Flow.Util.uuid());
      }
      classificationParameter = find(parameters, function(parameter) {
        return parameter.name === 'do_classification';
      });
      if (classificationParameter) {
        classificationParameter.actual_value = true;
      }
      return _.requestFrames(function(error, frames) {
        var frame, frameKeys, frameParameters, j, len, parameter;
        if (error) {

        } else {
          frameKeys = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = frames.length; j < len; j++) {
              frame = frames[j];
              results.push(frame.frame_id.name);
            }
            return results;
          })();
          frameParameters = filter(parameters, function(parameter) {
            return parameter.type === 'Key<Frame>';
          });
          for (j = 0, len = frameParameters.length; j < len; j++) {
            parameter = frameParameters[j];
            parameter.values = frameKeys;
            if (parameter.name === 'training_frame') {
              if (frameKey) {
                parameter.actual_value = frameKey;
              } else {
                frameKey = parameter.actual_value;
              }
            }
          }
          return go();
        }
      });
    };
    (function() {
      return _.requestModelBuilders(function(error, modelBuilders) {
        var frameKey;
        _algorithms(modelBuilders);
        _algorithm(_algo ? find(modelBuilders, function(builder) {
          return builder.algo === _algo;
        }) : void 0);
        frameKey = _opts != null ? _opts.training_frame : void 0;
        return act(_algorithm, function(builder) {
          var algorithm, parameters;
          if (builder) {
            algorithm = builder.algo;
            parameters = deepClone(builder.parameters);
            return populateFramesAndColumns(frameKey, algorithm, parameters, function() {
              return _modelForm(H2O.ModelBuilderForm(_, algorithm, parameters));
            });
          } else {
            return _modelForm(null);
          }
        });
      });
    })();
    createModel = function() {
      return _modelForm().createModel();
    };
    defer(_go);
    return {
      parentException: _exception,
      algorithms: _algorithms,
      algorithm: _algorithm,
      modelForm: _modelForm,
      canCreateModel: _canCreateModel,
      createModel: createModel,
      template: 'flow-model-input'
    };
  };

}).call(this);
